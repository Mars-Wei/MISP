# Model-based ISP Agent
from .utils import semantic_unit_segment


class Agent:
    """
    This is the class for Model-based Interactive Semantic Parsing (MISP) agent.
    """
    def __init__(self, world_model, error_detector, question_generator):
        """
        The constructor for Agent class.
        :param world_model: An instance of MISP_SQL.WorldModel.
        :param error_detector: An instance of MISP_SQL.ErrorDetector.
        :param question_generator: An instance of MISP_SQL.QuestionGenerator.
        """
        self.world_model = world_model
        self.error_detector = error_detector
        self.q_gen = question_generator

    def verified_qa(self, user, question, answer_sheet, pointer, tag_seq):
        """
        Q&A interaction.
        :param user: the user to interact with.
        :param question: the question to the user.
        :param answer_sheet: a dict of {user response: meta info};
               used by user simulator to generate proper feedback.
        :param pointer: the pointer to the questioned unit in the tagged sequence.
        :param tag_seq: a sequence of tagged semantic units.
        :return: user_feedback.
        """
        print("Question: %s" % question)
        user_feedback = user.get_answer(pointer, answer_sheet)
        user.record_user_feedback(tag_seq[pointer], user_feedback)

        return user_feedback

    def verified_opt_selection(self, user, opt_question, pointer, seg, opt_answer_sheet, sel_none_of_above):
        """
        User selection.
        :param user: the user to interact with.
        :param opt_question: the question and the options to the user.
        :param pointer: the pointer to the questioned unit in the tagged sequence.
        :param seg: the questioned semantic unit.
        :param opt_answer_sheet: a dict of {user selection: meta info};
               used by user simulator to select proper choices.
        :param sel_none_of_above: the index of "none of the above".
        :return: user_selections.
        """
        print("Question: %s" % opt_question)
        user_selections = user.get_selection(pointer, opt_answer_sheet, sel_none_of_above)
        user.option_selections.append((seg[0][0], opt_question, user_selections))

        return user_selections

    def interactive_parsing_session(self, user, input_item, true_output, hyp, bool_verbal=False):
        """
        Interaction session.
        :param user: the user to interact.
        :param input_item: the input to the semantic parser; this is specific to the base parser.
        :param true_output: the true SQL; used by evaluator in user simulation.
        :param hyp: the initial hypothesis generated by the non-interactive base parser.
        :param bool_verbal: set to True to print details about decoding.
        :return: hyp, True/False (whether user exits)
        """
        # setup
        user.update_truth(true_output)
        user.update_pred(hyp.tag_seq)
        user.clear_counter()
        self.world_model.clear()

        # error detection
        start_pos = 0
        err_segment_pointer_pairs = self.error_detector.detection(
            hyp.tag_seq, start_pos=start_pos, bool_return_first=True)

        while len(err_segment_pointer_pairs): # for each potential erroneous unit
            seg, pointer = err_segment_pointer_pairs[0]
            seg_id = seg[0][0]
            print("SU: {}".format(seg)) # SU = Semantic Unit

            # question generation
            question, answer_sheet = self.q_gen.question_generation(seg, hyp.tag_seq, pointer)
            if len(question):
                # user Q&A interaction
                user_feedback = self.verified_qa(user, question, answer_sheet, pointer, hyp.tag_seq)
                if user_feedback == "exit":
                    return hyp, True

                if answer_sheet[user_feedback][0]: # user affirms the decision
                    self.world_model.apply_pos_feedback(seg, hyp.dec_seq) # update confirmed items
                    start_pos = pointer + 1
                else: # user negates the decision
                    if answer_sheet[user_feedback][1] in {0, 2}: # type 0/2 unit (see question_gen.py)
                        dec_seq_idx = seg[0][-1]
                        # update negated items & perform one-step beam search
                        self.world_model.apply_neg_feedback(answer_sheet[user_feedback][1], seg, hyp.dec_seq)
                        cand_hypotheses = self.world_model.decode(
                            input_item, dec_beam_size=self.world_model.num_options,
                            dec_prefix=hyp.dec_seq[:dec_seq_idx],
                            avoid_items=self.world_model.avoid_items,
                            confirmed_items=self.world_model.confirmed_items,
                            stop_step=dec_seq_idx, bool_collect_choices=True,
                            bool_verbal=bool_verbal)

                        # prepare options
                        cand_hypotheses_segs = []
                        for cand_hyp in cand_hypotheses:
                            cand_segs, cand_pointers = semantic_unit_segment(cand_hyp.tag_seq)
                            assert cand_segs[-1][0][0] == seg_id
                            cand_hypotheses_segs.append(cand_segs[-1])

                        # present options
                        opt_question, opt_answer_sheet, sel_none_of_above = self.q_gen.option_generation(
                            cand_hypotheses_segs, hyp.tag_seq, pointer)

                        # user selection
                        user_selections = self.verified_opt_selection(
                            user, opt_question, pointer, seg, opt_answer_sheet, sel_none_of_above)

                        dec_prefix = hyp.dec_seq[:dec_seq_idx]  # for re-decode
                        for idx in range(len(opt_answer_sheet)): # user selection feedback incorporation
                            if idx + 1 in user_selections:
                                # update dec_prefix for components whose only choice is selected
                                dec_prefix = self.world_model.apply_pos_feedback(
                                    cand_hypotheses_segs[idx], cand_hypotheses[idx].dec_seq)
                            else:
                                self.world_model.apply_neg_feedback(
                                    answer_sheet[user_feedback][1], cand_hypotheses_segs[idx], hyp.dec_seq)

                        # if the user selects any valid choices or the unit is in type 0
                        if user_selections != [sel_none_of_above] or answer_sheet[user_feedback][1] == 0:
                            assert sel_none_of_above not in user_selections or answer_sheet[user_feedback][1] == 0
                            try:
                                partial_hyp = self.world_model.decode(
                                    input_item, dec_prefix=dec_prefix,
                                    avoid_items=self.world_model.avoid_items,
                                    confirmed_items=self.world_model.confirmed_items,
                                    stop_step=dec_seq_idx,
                                    bool_verbal=bool_verbal)[0]
                            except Exception: # e.g., when any WHERE_COL is redundant
                                if self.world_model.bool_str_revisable:
                                    start_pos, hyp = self.world_model.decode_revised_structure(
                                        seg, pointer, hyp, input_item, bool_verbal=bool_verbal)
                                else:
                                    start_pos = pointer + 1
                                user.update_pred(hyp.tag_seq)
                                err_segment_pointer_pairs = self.error_detector.detection(
                                    hyp.tag_seq, start_pos=start_pos, bool_return_first=True)
                                continue
                            else:
                                # the following finds the next pointer to validate
                                _, cand_pointers = semantic_unit_segment(partial_hyp.tag_seq)
                                last_pointer = cand_pointers[-1]
                                if last_pointer < pointer: # structure changed, e.g., #cols reduce
                                    start_pos = last_pointer + 1
                                else:
                                    start_pos = pointer + 1

                                # generate a new hypothesis after interaction
                                hyp = self.world_model.decode(
                                    input_item, dec_prefix=dec_prefix,
                                    avoid_items=self.world_model.avoid_items,
                                    confirmed_items=self.world_model.confirmed_items,
                                    bool_verbal=bool_verbal)[0]
                                user.update_pred(hyp.tag_seq)

                        else: # the user selects "none of the above"
                            if self.world_model.bool_seek:  # seek the next possible decision in the same position
                                try:
                                    hyp = self.world_model.decode(
                                        input_item, dec_beam_size=1,
                                        dec_prefix=hyp.dec_seq[:dec_seq_idx],
                                        avoid_items=self.world_model.avoid_items,
                                        confirmed_items=self.world_model.confirmed_items,
                                        bool_verbal=bool_verbal)[0]
                                except Exception:
                                    print("## WARNING: out of option for %s" % seg_id)
                                    if self.world_model.bool_str_revisable:  # remove this component (structure revised)
                                        start_pos, hyp = self.world_model.decode_revised_structure(
                                            seg, pointer, hyp, input_item, bool_verbal=bool_verbal)
                                        user.update_pred(hyp.tag_seq)
                                        err_segment_pointer_pairs = self.error_detector.detection(
                                            hyp.tag_seq, start_pos=start_pos, bool_return_first=True)
                                        continue

                            user.update_pred(hyp.tag_seq)
                            start_pos = pointer + 1

                    else: # type 1 unit: for decisions with only yes/no choices, we "flip" the current decision
                        assert answer_sheet[user_feedback][1] == 1
                        dec_prefix = self.world_model.apply_neg_feedback(answer_sheet[user_feedback][1], seg,
                                                                         hyp.dec_seq)
                        hyp = self.world_model.decode(input_item, dec_prefix=dec_prefix,
                                                      avoid_items=self.world_model.avoid_items,
                                                      confirmed_items=self.world_model.confirmed_items,
                                                      bool_verbal=bool_verbal)[0]
                        user.update_pred(hyp.tag_seq)
                        start_pos = pointer + 1

            else:
                print("WARNING: empty question in seg %s, pointer %d\n" % (seg, pointer))
                start_pos = pointer + 1

            # error detection in the next turn
            err_segment_pointer_pairs = self.error_detector.detection(
                hyp.tag_seq, start_pos=start_pos, bool_return_first=True)

        return hyp, False
